Техническое задание

Тема: Сервис уведомлений с fallback по каналам (Email / SMS / Telegram)

1. Цель

Реализовать небольшой сервис, который:
	•	принимает запрос на отправку уведомления пользователю;
	•	пытается отправить это уведомление по нескольким каналам:
	•	Email
	•	SMS
	•	Telegram
	•	обеспечивает «надёжную доставку»:
если один канал не сработал — автоматически пробует следующий.

Сервис должен быть оформлен как мини-проект, который можно запустить локально и проверить через HTTP-запросы.

⸻

2. Функциональные требования

2.1. Базовый сценарий
	1.	Внешняя система (или тестировщик) отправляет HTTP-запрос в сервис:
	•	кому отправить (данные пользователя),
	•	текст сообщения,
	•	(опционально) заголовок,
	•	(опционально) порядок каналов.
	2.	Сервис:
	•	пытается отправить уведомление по каналам последовательно;
	•	как только один канал успешно доставил — прекращает попытки;
	•	если ни один канал не сработал — помечает уведомление как не доставленное.
	3.	Результат:
	•	можно запросить статус уведомления и увидеть:
	•	общий статус (delivered / failed),
	•	по каким каналам были попытки и чем они закончились.

⸻

3. Модель данных

Хранение — любая БД (можно SQLite), либо in-memory хранилище, но с чёткими сущностями.

3.1. Уведомление (Notification)

Обязательные поля:
	•	id — идентификатор уведомления.
	•	to_email — email получателя (опц.).
	•	to_phone — телефон для SMS (опц.).
	•	to_telegram_chat_id — chat_id Telegram (опц.).
	•	subject — заголовок (опц., используется для email).
	•	body — текст уведомления (обязателен).
	•	channels — список каналов, по которым разрешено отправлять, в порядке приоритета
(например: ["email", "sms", "telegram"]).
	•	status:
	•	pending — создано, ещё не отправлено,
	•	in_progress — выполняется отправка,
	•	delivered — хотя бы один канал успешно доставил,
	•	failed — все каналы закончились ошибкой.
	•	created_at, updated_at.

Если channels не переданы, можно использовать дефолтный порядок, например:
["email", "sms", "telegram"].

3.2. Попытка доставки (DeliveryAttempt)
	•	id
	•	notification_id
	•	channel — одно из: email, sms, telegram
	•	status — success / failed
	•	error_message — строка с описанием ошибки (если было).
	•	attempted_at — время попытки.

⸻

4. Логика работы каналов

Реальная интеграция с провайдерами не обязательна. Достаточно заглушек, которые:
	•	имитируют отправку;
	•	иногда могут «падать» для демонстрации fallback’а;
	•	логируют факт отправки и результат.

4.1. Email
	•	Отправка на to_email.
	•	Если to_email отсутствует → канал считается недоступным, попытка не делается.
	•	При ошибке (например, искусственно вызванной) → зафиксировать failed и перейти к следующему каналу.

4.2. SMS
	•	Отправка на to_phone.
	•	Нет to_phone → канал недоступен.
	•	Ошибка провайдера (эмулируем) → failed.

4.3. Telegram
	•	Отправка через Telegram Bot API или имитация вызова.
	•	Нет to_telegram_chat_id → канал недоступен.
	•	Ошибка API (эмулируем) → failed.

⸻

5. Fallback-логика (надёжная доставка)

Для каждого уведомления:
	1.	Взять список каналов в порядке приоритета:
	•	если передан в запросе — использовать его;
	•	иначе использовать дефолтный (например, ["email", "sms", "telegram"]).
	2.	Для каждого канала по очереди:
	•	если канал недоступен (нет нужных данных: email/phone/chat_id) — сразу пометить попытку как failed с причиной и перейти к следующему;
	•	иначе вызвать соответствующий адаптер (email/sms/telegram).
	3.	Поведение в зависимости от результата:
	•	Если адаптер вернул успех:
	•	создать DeliveryAttempt со статусом success,
	•	пометить уведомление как delivered,
	•	прекратить дальнейшие попытки.
	•	Если адаптер вернул ошибку:
	•	создать DeliveryAttempt со статусом failed,
	•	перейти к следующему каналу.
	4.	Если все каналы обработаны и ни один не дал успеха:
	•	пометить уведомление как failed.

Достаточно одной попытки на канал, без сложной логики повторов.

⸻

6. HTTP API

Формат запросов/ответов — JSON.

6.1. Создать и отправить уведомление

Метод: POST /notifications

Тело запроса:
{
  "to_email": "user@example.com",
  "to_phone": "+49123456789",
  "to_telegram_chat_id": "123456789",
  "subject": "Test notification",
  "body": "Hello, this is a test",
  "channels": ["telegram", "email", "sms"]
}

Пояснения:
	•	Контакты (to_email, to_phone, to_telegram_chat_id) — все опциональные, но хотя бы один должен быть указан, иначе запрос невалиден.
	•	channels — опционален:
	•	если не указан → используется дефолтный список, заданный в коде.

Ответ (201):
{
  "id": "notification-id",
  "status": "delivered",
  "used_channel": "email"
}

Или, если отправка асинхронная:
{
  "id": "notification-id",
  "status": "pending"
}

На выбор исполнителя:
	•	либо выполнить отправку синхронно в рамках запроса и вернуть финальный статус;
	•	либо сделать отправку асинхронной и вернуть pending с последующим запросом статуса.

6.2. Получить статус уведомления

Метод: GET /notifications/{id}

Ответ:

{
  "id": "notification-id",
  "status": "delivered",
  "subject": "Test notification",
  "body": "Hello, this is a test",
  "attempts": [
    {
      "channel": "telegram",
      "status": "failed",
      "error_message": "No telegram_chat_id provided",
      "attempted_at": "2025-11-19T12:00:00Z"
    },
    {
      "channel": "email",
      "status": "success",
      "error_message": null,
      "attempted_at": "2025-11-19T12:00:01Z"
    }
  ]
}

Если уведомление не найдено — вернуть 404.

⸻

7. Нефункциональные требования
	•	Язык/фреймворк — любой на выбор кандидата (указать в README).
	•	Сервис должен подниматься одной командой (например, docker-compose up или make run / python main.py).
	•	Должен быть README, в котором описано:
	•	как запустить сервис,
	•	примеры запросов (curl / httpie / Postman).
	•	Логи:
	•	выводить в консоль информацию о попытках доставки с указанием канала и результата.

⸻

8. Что ожидается на выходе

Кандидат должен предоставить:
	1.	Исходный код (Git-репозиторий или архив).
	2.	README с инструкцией по запуску и примерами запросов.
	3.	Реализованный HTTP API по ТЗ.
	4.	Реализованную fallback-логику между Email / SMS / Telegram с логированием и историей попыток.